// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/knovalab-systems/vytex/app/v1/models"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newImageByReference(db *gorm.DB, opts ...gen.DOOption) imageByReference {
	_imageByReference := imageByReference{}

	_imageByReference.imageByReferenceDo.UseDB(db, opts...)
	_imageByReference.imageByReferenceDo.UseModel(&models.ImageByReference{})

	tableName := _imageByReference.imageByReferenceDo.TableName()
	_imageByReference.ALL = field.NewAsterisk(tableName)
	_imageByReference.ID = field.NewUint(tableName, "id")
	_imageByReference.ImageID = field.NewString(tableName, "image_id")
	_imageByReference.ReferenceID = field.NewUint(tableName, "reference_id")
	_imageByReference.Image = imageByReferenceBelongsToImage{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Image", "models.Image"),
	}

	_imageByReference.Reference = imageByReferenceBelongsToReference{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Reference", "models.Reference"),
		User: struct {
			field.RelationField
			Role struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Reference.User", "models.User"),
			Role: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.User.Role", "models.Role"),
			},
		},
		FrontImage: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.FrontImage", "models.Image"),
		},
		BackImage: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.BackImage", "models.Image"),
		},
		TimeByTask: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.TimeByTask", "models.TimeByTask"),
		},
		OperationalList: struct {
			field.RelationField
			Reference struct {
				field.RelationField
			}
			Operations struct {
				field.RelationField
				OperationalList struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Reference.OperationalList", "models.OperationalList"),
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.OperationalList.Reference", "models.Reference"),
			},
			Operations: struct {
				field.RelationField
				OperationalList struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Reference.OperationalList.Operations", "models.Operation"),
				OperationalList: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Reference.OperationalList.Operations.OperationalList", "models.OperationalList"),
				},
			},
		},
		Colors: struct {
			field.RelationField
			Color struct {
				field.RelationField
			}
			Reference struct {
				field.RelationField
			}
			Resources struct {
				field.RelationField
				Resource struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}
			}
			Fabrics struct {
				field.RelationField
				Fabric struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}
			}
		}{
			RelationField: field.NewRelation("Reference.Colors", "models.ColorByReference"),
			Color: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Colors.Color", "models.Color"),
			},
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Colors.Reference", "models.Reference"),
			},
			Resources: struct {
				field.RelationField
				Resource struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Reference.Colors.Resources", "models.ResourceByReference"),
				Resource: struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Reference.Colors.Resources.Resource", "models.Resource"),
					Color: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Resources.Resource.Color", "models.Color"),
					},
					Supplier: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Resources.Resource.Supplier", "models.Supplier"),
					},
				},
			},
			Fabrics: struct {
				field.RelationField
				Fabric struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Reference.Colors.Fabrics", "models.FabricByReference"),
				Fabric: struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric", "models.Fabric"),
					Color: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Color", "models.Color"),
					},
					Supplier: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Supplier", "models.Supplier"),
					},
					Composition: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Composition", "models.Composition"),
					},
				},
			},
		},
		Pieces: struct {
			field.RelationField
			Image struct {
				field.RelationField
			}
			Reference struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Reference.Pieces", "models.ImageByReference"),
			Image: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Pieces.Image", "models.Image"),
			},
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Pieces.Reference", "models.Reference"),
			},
		},
	}

	_imageByReference.fillFieldMap()

	return _imageByReference
}

type imageByReference struct {
	imageByReferenceDo

	ALL         field.Asterisk
	ID          field.Uint
	ImageID     field.String
	ReferenceID field.Uint
	Image       imageByReferenceBelongsToImage

	Reference imageByReferenceBelongsToReference

	fieldMap map[string]field.Expr
}

func (i imageByReference) Table(newTableName string) *imageByReference {
	i.imageByReferenceDo.UseTable(newTableName)
	return i.updateTableName(newTableName)
}

func (i imageByReference) As(alias string) *imageByReference {
	i.imageByReferenceDo.DO = *(i.imageByReferenceDo.As(alias).(*gen.DO))
	return i.updateTableName(alias)
}

func (i *imageByReference) updateTableName(table string) *imageByReference {
	i.ALL = field.NewAsterisk(table)
	i.ID = field.NewUint(table, "id")
	i.ImageID = field.NewString(table, "image_id")
	i.ReferenceID = field.NewUint(table, "reference_id")

	i.fillFieldMap()

	return i
}

func (i *imageByReference) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := i.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (i *imageByReference) fillFieldMap() {
	i.fieldMap = make(map[string]field.Expr, 5)
	i.fieldMap["id"] = i.ID
	i.fieldMap["image_id"] = i.ImageID
	i.fieldMap["reference_id"] = i.ReferenceID

}

func (i imageByReference) clone(db *gorm.DB) imageByReference {
	i.imageByReferenceDo.ReplaceConnPool(db.Statement.ConnPool)
	return i
}

func (i imageByReference) replaceDB(db *gorm.DB) imageByReference {
	i.imageByReferenceDo.ReplaceDB(db)
	return i
}

type imageByReferenceBelongsToImage struct {
	db *gorm.DB

	field.RelationField
}

func (a imageByReferenceBelongsToImage) Where(conds ...field.Expr) *imageByReferenceBelongsToImage {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a imageByReferenceBelongsToImage) WithContext(ctx context.Context) *imageByReferenceBelongsToImage {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a imageByReferenceBelongsToImage) Session(session *gorm.Session) *imageByReferenceBelongsToImage {
	a.db = a.db.Session(session)
	return &a
}

func (a imageByReferenceBelongsToImage) Model(m *models.ImageByReference) *imageByReferenceBelongsToImageTx {
	return &imageByReferenceBelongsToImageTx{a.db.Model(m).Association(a.Name())}
}

type imageByReferenceBelongsToImageTx struct{ tx *gorm.Association }

func (a imageByReferenceBelongsToImageTx) Find() (result *models.Image, err error) {
	return result, a.tx.Find(&result)
}

func (a imageByReferenceBelongsToImageTx) Append(values ...*models.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a imageByReferenceBelongsToImageTx) Replace(values ...*models.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a imageByReferenceBelongsToImageTx) Delete(values ...*models.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a imageByReferenceBelongsToImageTx) Clear() error {
	return a.tx.Clear()
}

func (a imageByReferenceBelongsToImageTx) Count() int64 {
	return a.tx.Count()
}

type imageByReferenceBelongsToReference struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		Role struct {
			field.RelationField
		}
	}
	FrontImage struct {
		field.RelationField
	}
	BackImage struct {
		field.RelationField
	}
	TimeByTask struct {
		field.RelationField
	}
	OperationalList struct {
		field.RelationField
		Reference struct {
			field.RelationField
		}
		Operations struct {
			field.RelationField
			OperationalList struct {
				field.RelationField
			}
		}
	}
	Colors struct {
		field.RelationField
		Color struct {
			field.RelationField
		}
		Reference struct {
			field.RelationField
		}
		Resources struct {
			field.RelationField
			Resource struct {
				field.RelationField
				Color struct {
					field.RelationField
				}
				Supplier struct {
					field.RelationField
				}
			}
		}
		Fabrics struct {
			field.RelationField
			Fabric struct {
				field.RelationField
				Color struct {
					field.RelationField
				}
				Supplier struct {
					field.RelationField
				}
				Composition struct {
					field.RelationField
				}
			}
		}
	}
	Pieces struct {
		field.RelationField
		Image struct {
			field.RelationField
		}
		Reference struct {
			field.RelationField
		}
	}
}

func (a imageByReferenceBelongsToReference) Where(conds ...field.Expr) *imageByReferenceBelongsToReference {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a imageByReferenceBelongsToReference) WithContext(ctx context.Context) *imageByReferenceBelongsToReference {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a imageByReferenceBelongsToReference) Session(session *gorm.Session) *imageByReferenceBelongsToReference {
	a.db = a.db.Session(session)
	return &a
}

func (a imageByReferenceBelongsToReference) Model(m *models.ImageByReference) *imageByReferenceBelongsToReferenceTx {
	return &imageByReferenceBelongsToReferenceTx{a.db.Model(m).Association(a.Name())}
}

type imageByReferenceBelongsToReferenceTx struct{ tx *gorm.Association }

func (a imageByReferenceBelongsToReferenceTx) Find() (result *models.Reference, err error) {
	return result, a.tx.Find(&result)
}

func (a imageByReferenceBelongsToReferenceTx) Append(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a imageByReferenceBelongsToReferenceTx) Replace(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a imageByReferenceBelongsToReferenceTx) Delete(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a imageByReferenceBelongsToReferenceTx) Clear() error {
	return a.tx.Clear()
}

func (a imageByReferenceBelongsToReferenceTx) Count() int64 {
	return a.tx.Count()
}

type imageByReferenceDo struct{ gen.DO }

type IImageByReferenceDo interface {
	gen.SubQuery
	Debug() IImageByReferenceDo
	WithContext(ctx context.Context) IImageByReferenceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IImageByReferenceDo
	WriteDB() IImageByReferenceDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IImageByReferenceDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IImageByReferenceDo
	Not(conds ...gen.Condition) IImageByReferenceDo
	Or(conds ...gen.Condition) IImageByReferenceDo
	Select(conds ...field.Expr) IImageByReferenceDo
	Where(conds ...gen.Condition) IImageByReferenceDo
	Order(conds ...field.Expr) IImageByReferenceDo
	Distinct(cols ...field.Expr) IImageByReferenceDo
	Omit(cols ...field.Expr) IImageByReferenceDo
	Join(table schema.Tabler, on ...field.Expr) IImageByReferenceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IImageByReferenceDo
	RightJoin(table schema.Tabler, on ...field.Expr) IImageByReferenceDo
	Group(cols ...field.Expr) IImageByReferenceDo
	Having(conds ...gen.Condition) IImageByReferenceDo
	Limit(limit int) IImageByReferenceDo
	Offset(offset int) IImageByReferenceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IImageByReferenceDo
	Unscoped() IImageByReferenceDo
	Create(values ...*models.ImageByReference) error
	CreateInBatches(values []*models.ImageByReference, batchSize int) error
	Save(values ...*models.ImageByReference) error
	First() (*models.ImageByReference, error)
	Take() (*models.ImageByReference, error)
	Last() (*models.ImageByReference, error)
	Find() ([]*models.ImageByReference, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ImageByReference, err error)
	FindInBatches(result *[]*models.ImageByReference, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.ImageByReference) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IImageByReferenceDo
	Assign(attrs ...field.AssignExpr) IImageByReferenceDo
	Joins(fields ...field.RelationField) IImageByReferenceDo
	Preload(fields ...field.RelationField) IImageByReferenceDo
	FirstOrInit() (*models.ImageByReference, error)
	FirstOrCreate() (*models.ImageByReference, error)
	FindByPage(offset int, limit int) (result []*models.ImageByReference, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IImageByReferenceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (i imageByReferenceDo) Debug() IImageByReferenceDo {
	return i.withDO(i.DO.Debug())
}

func (i imageByReferenceDo) WithContext(ctx context.Context) IImageByReferenceDo {
	return i.withDO(i.DO.WithContext(ctx))
}

func (i imageByReferenceDo) ReadDB() IImageByReferenceDo {
	return i.Clauses(dbresolver.Read)
}

func (i imageByReferenceDo) WriteDB() IImageByReferenceDo {
	return i.Clauses(dbresolver.Write)
}

func (i imageByReferenceDo) Session(config *gorm.Session) IImageByReferenceDo {
	return i.withDO(i.DO.Session(config))
}

func (i imageByReferenceDo) Clauses(conds ...clause.Expression) IImageByReferenceDo {
	return i.withDO(i.DO.Clauses(conds...))
}

func (i imageByReferenceDo) Returning(value interface{}, columns ...string) IImageByReferenceDo {
	return i.withDO(i.DO.Returning(value, columns...))
}

func (i imageByReferenceDo) Not(conds ...gen.Condition) IImageByReferenceDo {
	return i.withDO(i.DO.Not(conds...))
}

func (i imageByReferenceDo) Or(conds ...gen.Condition) IImageByReferenceDo {
	return i.withDO(i.DO.Or(conds...))
}

func (i imageByReferenceDo) Select(conds ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Select(conds...))
}

func (i imageByReferenceDo) Where(conds ...gen.Condition) IImageByReferenceDo {
	return i.withDO(i.DO.Where(conds...))
}

func (i imageByReferenceDo) Order(conds ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Order(conds...))
}

func (i imageByReferenceDo) Distinct(cols ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Distinct(cols...))
}

func (i imageByReferenceDo) Omit(cols ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Omit(cols...))
}

func (i imageByReferenceDo) Join(table schema.Tabler, on ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Join(table, on...))
}

func (i imageByReferenceDo) LeftJoin(table schema.Tabler, on ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.LeftJoin(table, on...))
}

func (i imageByReferenceDo) RightJoin(table schema.Tabler, on ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.RightJoin(table, on...))
}

func (i imageByReferenceDo) Group(cols ...field.Expr) IImageByReferenceDo {
	return i.withDO(i.DO.Group(cols...))
}

func (i imageByReferenceDo) Having(conds ...gen.Condition) IImageByReferenceDo {
	return i.withDO(i.DO.Having(conds...))
}

func (i imageByReferenceDo) Limit(limit int) IImageByReferenceDo {
	return i.withDO(i.DO.Limit(limit))
}

func (i imageByReferenceDo) Offset(offset int) IImageByReferenceDo {
	return i.withDO(i.DO.Offset(offset))
}

func (i imageByReferenceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IImageByReferenceDo {
	return i.withDO(i.DO.Scopes(funcs...))
}

func (i imageByReferenceDo) Unscoped() IImageByReferenceDo {
	return i.withDO(i.DO.Unscoped())
}

func (i imageByReferenceDo) Create(values ...*models.ImageByReference) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Create(values)
}

func (i imageByReferenceDo) CreateInBatches(values []*models.ImageByReference, batchSize int) error {
	return i.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (i imageByReferenceDo) Save(values ...*models.ImageByReference) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Save(values)
}

func (i imageByReferenceDo) First() (*models.ImageByReference, error) {
	if result, err := i.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.ImageByReference), nil
	}
}

func (i imageByReferenceDo) Take() (*models.ImageByReference, error) {
	if result, err := i.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.ImageByReference), nil
	}
}

func (i imageByReferenceDo) Last() (*models.ImageByReference, error) {
	if result, err := i.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.ImageByReference), nil
	}
}

func (i imageByReferenceDo) Find() ([]*models.ImageByReference, error) {
	result, err := i.DO.Find()
	return result.([]*models.ImageByReference), err
}

func (i imageByReferenceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ImageByReference, err error) {
	buf := make([]*models.ImageByReference, 0, batchSize)
	err = i.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (i imageByReferenceDo) FindInBatches(result *[]*models.ImageByReference, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return i.DO.FindInBatches(result, batchSize, fc)
}

func (i imageByReferenceDo) Attrs(attrs ...field.AssignExpr) IImageByReferenceDo {
	return i.withDO(i.DO.Attrs(attrs...))
}

func (i imageByReferenceDo) Assign(attrs ...field.AssignExpr) IImageByReferenceDo {
	return i.withDO(i.DO.Assign(attrs...))
}

func (i imageByReferenceDo) Joins(fields ...field.RelationField) IImageByReferenceDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Joins(_f))
	}
	return &i
}

func (i imageByReferenceDo) Preload(fields ...field.RelationField) IImageByReferenceDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Preload(_f))
	}
	return &i
}

func (i imageByReferenceDo) FirstOrInit() (*models.ImageByReference, error) {
	if result, err := i.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.ImageByReference), nil
	}
}

func (i imageByReferenceDo) FirstOrCreate() (*models.ImageByReference, error) {
	if result, err := i.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.ImageByReference), nil
	}
}

func (i imageByReferenceDo) FindByPage(offset int, limit int) (result []*models.ImageByReference, count int64, err error) {
	result, err = i.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = i.Offset(-1).Limit(-1).Count()
	return
}

func (i imageByReferenceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = i.Count()
	if err != nil {
		return
	}

	err = i.Offset(offset).Limit(limit).Scan(result)
	return
}

func (i imageByReferenceDo) Scan(result interface{}) (err error) {
	return i.DO.Scan(result)
}

func (i imageByReferenceDo) Delete(models ...*models.ImageByReference) (result gen.ResultInfo, err error) {
	return i.DO.Delete(models)
}

func (i *imageByReferenceDo) withDO(do gen.Dao) *imageByReferenceDo {
	i.DO = *do.(*gen.DO)
	return i
}
