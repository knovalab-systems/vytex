// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/knovalab-systems/vytex/app/v1/models"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newOperationalList(db *gorm.DB, opts ...gen.DOOption) operationalList {
	_operationalList := operationalList{}

	_operationalList.operationalListDo.UseDB(db, opts...)
	_operationalList.operationalListDo.UseModel(&models.OperationalList{})

	tableName := _operationalList.operationalListDo.TableName()
	_operationalList.ALL = field.NewAsterisk(tableName)
	_operationalList.ID = field.NewUint(tableName, "id")
	_operationalList.ReferenceID = field.NewUint(tableName, "reference_id")
	_operationalList.Reference = operationalListHasOneReference{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Reference", "models.Reference"),
		User: struct {
			field.RelationField
			Role struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Reference.User", "models.User"),
			Role: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.User.Role", "models.Role"),
			},
		},
		FrontImage: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.FrontImage", "models.Image"),
		},
		BackImage: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.BackImage", "models.Image"),
		},
		TimeByTask: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Reference.TimeByTask", "models.TimeByTask"),
		},
		OperationalList: struct {
			field.RelationField
			Reference struct {
				field.RelationField
			}
			Operations struct {
				field.RelationField
				OperationalList struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Reference.OperationalList", "models.OperationalList"),
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.OperationalList.Reference", "models.Reference"),
			},
			Operations: struct {
				field.RelationField
				OperationalList struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Reference.OperationalList.Operations", "models.Operation"),
				OperationalList: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Reference.OperationalList.Operations.OperationalList", "models.OperationalList"),
				},
			},
		},
		Colors: struct {
			field.RelationField
			Color struct {
				field.RelationField
			}
			Reference struct {
				field.RelationField
			}
			Resources struct {
				field.RelationField
				Resource struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}
			}
			Fabrics struct {
				field.RelationField
				Fabric struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}
			}
		}{
			RelationField: field.NewRelation("Reference.Colors", "models.ColorByReference"),
			Color: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Colors.Color", "models.Color"),
			},
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Colors.Reference", "models.Reference"),
			},
			Resources: struct {
				field.RelationField
				Resource struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Reference.Colors.Resources", "models.ResourceByReference"),
				Resource: struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Reference.Colors.Resources.Resource", "models.Resource"),
					Color: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Resources.Resource.Color", "models.Color"),
					},
					Supplier: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Resources.Resource.Supplier", "models.Supplier"),
					},
				},
			},
			Fabrics: struct {
				field.RelationField
				Fabric struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Reference.Colors.Fabrics", "models.FabricByReference"),
				Fabric: struct {
					field.RelationField
					Color struct {
						field.RelationField
					}
					Supplier struct {
						field.RelationField
					}
					Composition struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric", "models.Fabric"),
					Color: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Color", "models.Color"),
					},
					Supplier: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Supplier", "models.Supplier"),
					},
					Composition: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Reference.Colors.Fabrics.Fabric.Composition", "models.Composition"),
					},
				},
			},
		},
		Pieces: struct {
			field.RelationField
			Image struct {
				field.RelationField
			}
			Reference struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Reference.Pieces", "models.ImageByReference"),
			Image: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Pieces.Image", "models.Image"),
			},
			Reference: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Reference.Pieces.Reference", "models.Reference"),
			},
		},
	}

	_operationalList.Operations = operationalListHasManyOperations{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Operations", "models.Operation"),
	}

	_operationalList.fillFieldMap()

	return _operationalList
}

type operationalList struct {
	operationalListDo

	ALL         field.Asterisk
	ID          field.Uint
	ReferenceID field.Uint
	Reference   operationalListHasOneReference

	Operations operationalListHasManyOperations

	fieldMap map[string]field.Expr
}

func (o operationalList) Table(newTableName string) *operationalList {
	o.operationalListDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o operationalList) As(alias string) *operationalList {
	o.operationalListDo.DO = *(o.operationalListDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *operationalList) updateTableName(table string) *operationalList {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewUint(table, "id")
	o.ReferenceID = field.NewUint(table, "reference_id")

	o.fillFieldMap()

	return o
}

func (o *operationalList) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *operationalList) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 4)
	o.fieldMap["id"] = o.ID
	o.fieldMap["reference_id"] = o.ReferenceID

}

func (o operationalList) clone(db *gorm.DB) operationalList {
	o.operationalListDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o operationalList) replaceDB(db *gorm.DB) operationalList {
	o.operationalListDo.ReplaceDB(db)
	return o
}

type operationalListHasOneReference struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		Role struct {
			field.RelationField
		}
	}
	FrontImage struct {
		field.RelationField
	}
	BackImage struct {
		field.RelationField
	}
	TimeByTask struct {
		field.RelationField
	}
	OperationalList struct {
		field.RelationField
		Reference struct {
			field.RelationField
		}
		Operations struct {
			field.RelationField
			OperationalList struct {
				field.RelationField
			}
		}
	}
	Colors struct {
		field.RelationField
		Color struct {
			field.RelationField
		}
		Reference struct {
			field.RelationField
		}
		Resources struct {
			field.RelationField
			Resource struct {
				field.RelationField
				Color struct {
					field.RelationField
				}
				Supplier struct {
					field.RelationField
				}
			}
		}
		Fabrics struct {
			field.RelationField
			Fabric struct {
				field.RelationField
				Color struct {
					field.RelationField
				}
				Supplier struct {
					field.RelationField
				}
				Composition struct {
					field.RelationField
				}
			}
		}
	}
	Pieces struct {
		field.RelationField
		Image struct {
			field.RelationField
		}
		Reference struct {
			field.RelationField
		}
	}
}

func (a operationalListHasOneReference) Where(conds ...field.Expr) *operationalListHasOneReference {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a operationalListHasOneReference) WithContext(ctx context.Context) *operationalListHasOneReference {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a operationalListHasOneReference) Session(session *gorm.Session) *operationalListHasOneReference {
	a.db = a.db.Session(session)
	return &a
}

func (a operationalListHasOneReference) Model(m *models.OperationalList) *operationalListHasOneReferenceTx {
	return &operationalListHasOneReferenceTx{a.db.Model(m).Association(a.Name())}
}

type operationalListHasOneReferenceTx struct{ tx *gorm.Association }

func (a operationalListHasOneReferenceTx) Find() (result *models.Reference, err error) {
	return result, a.tx.Find(&result)
}

func (a operationalListHasOneReferenceTx) Append(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a operationalListHasOneReferenceTx) Replace(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a operationalListHasOneReferenceTx) Delete(values ...*models.Reference) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a operationalListHasOneReferenceTx) Clear() error {
	return a.tx.Clear()
}

func (a operationalListHasOneReferenceTx) Count() int64 {
	return a.tx.Count()
}

type operationalListHasManyOperations struct {
	db *gorm.DB

	field.RelationField
}

func (a operationalListHasManyOperations) Where(conds ...field.Expr) *operationalListHasManyOperations {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a operationalListHasManyOperations) WithContext(ctx context.Context) *operationalListHasManyOperations {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a operationalListHasManyOperations) Session(session *gorm.Session) *operationalListHasManyOperations {
	a.db = a.db.Session(session)
	return &a
}

func (a operationalListHasManyOperations) Model(m *models.OperationalList) *operationalListHasManyOperationsTx {
	return &operationalListHasManyOperationsTx{a.db.Model(m).Association(a.Name())}
}

type operationalListHasManyOperationsTx struct{ tx *gorm.Association }

func (a operationalListHasManyOperationsTx) Find() (result []*models.Operation, err error) {
	return result, a.tx.Find(&result)
}

func (a operationalListHasManyOperationsTx) Append(values ...*models.Operation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a operationalListHasManyOperationsTx) Replace(values ...*models.Operation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a operationalListHasManyOperationsTx) Delete(values ...*models.Operation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a operationalListHasManyOperationsTx) Clear() error {
	return a.tx.Clear()
}

func (a operationalListHasManyOperationsTx) Count() int64 {
	return a.tx.Count()
}

type operationalListDo struct{ gen.DO }

type IOperationalListDo interface {
	gen.SubQuery
	Debug() IOperationalListDo
	WithContext(ctx context.Context) IOperationalListDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOperationalListDo
	WriteDB() IOperationalListDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOperationalListDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOperationalListDo
	Not(conds ...gen.Condition) IOperationalListDo
	Or(conds ...gen.Condition) IOperationalListDo
	Select(conds ...field.Expr) IOperationalListDo
	Where(conds ...gen.Condition) IOperationalListDo
	Order(conds ...field.Expr) IOperationalListDo
	Distinct(cols ...field.Expr) IOperationalListDo
	Omit(cols ...field.Expr) IOperationalListDo
	Join(table schema.Tabler, on ...field.Expr) IOperationalListDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOperationalListDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOperationalListDo
	Group(cols ...field.Expr) IOperationalListDo
	Having(conds ...gen.Condition) IOperationalListDo
	Limit(limit int) IOperationalListDo
	Offset(offset int) IOperationalListDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOperationalListDo
	Unscoped() IOperationalListDo
	Create(values ...*models.OperationalList) error
	CreateInBatches(values []*models.OperationalList, batchSize int) error
	Save(values ...*models.OperationalList) error
	First() (*models.OperationalList, error)
	Take() (*models.OperationalList, error)
	Last() (*models.OperationalList, error)
	Find() ([]*models.OperationalList, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.OperationalList, err error)
	FindInBatches(result *[]*models.OperationalList, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.OperationalList) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOperationalListDo
	Assign(attrs ...field.AssignExpr) IOperationalListDo
	Joins(fields ...field.RelationField) IOperationalListDo
	Preload(fields ...field.RelationField) IOperationalListDo
	FirstOrInit() (*models.OperationalList, error)
	FirstOrCreate() (*models.OperationalList, error)
	FindByPage(offset int, limit int) (result []*models.OperationalList, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOperationalListDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o operationalListDo) Debug() IOperationalListDo {
	return o.withDO(o.DO.Debug())
}

func (o operationalListDo) WithContext(ctx context.Context) IOperationalListDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o operationalListDo) ReadDB() IOperationalListDo {
	return o.Clauses(dbresolver.Read)
}

func (o operationalListDo) WriteDB() IOperationalListDo {
	return o.Clauses(dbresolver.Write)
}

func (o operationalListDo) Session(config *gorm.Session) IOperationalListDo {
	return o.withDO(o.DO.Session(config))
}

func (o operationalListDo) Clauses(conds ...clause.Expression) IOperationalListDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o operationalListDo) Returning(value interface{}, columns ...string) IOperationalListDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o operationalListDo) Not(conds ...gen.Condition) IOperationalListDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o operationalListDo) Or(conds ...gen.Condition) IOperationalListDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o operationalListDo) Select(conds ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o operationalListDo) Where(conds ...gen.Condition) IOperationalListDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o operationalListDo) Order(conds ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o operationalListDo) Distinct(cols ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o operationalListDo) Omit(cols ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o operationalListDo) Join(table schema.Tabler, on ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o operationalListDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o operationalListDo) RightJoin(table schema.Tabler, on ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o operationalListDo) Group(cols ...field.Expr) IOperationalListDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o operationalListDo) Having(conds ...gen.Condition) IOperationalListDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o operationalListDo) Limit(limit int) IOperationalListDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o operationalListDo) Offset(offset int) IOperationalListDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o operationalListDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOperationalListDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o operationalListDo) Unscoped() IOperationalListDo {
	return o.withDO(o.DO.Unscoped())
}

func (o operationalListDo) Create(values ...*models.OperationalList) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o operationalListDo) CreateInBatches(values []*models.OperationalList, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o operationalListDo) Save(values ...*models.OperationalList) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o operationalListDo) First() (*models.OperationalList, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.OperationalList), nil
	}
}

func (o operationalListDo) Take() (*models.OperationalList, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.OperationalList), nil
	}
}

func (o operationalListDo) Last() (*models.OperationalList, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.OperationalList), nil
	}
}

func (o operationalListDo) Find() ([]*models.OperationalList, error) {
	result, err := o.DO.Find()
	return result.([]*models.OperationalList), err
}

func (o operationalListDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.OperationalList, err error) {
	buf := make([]*models.OperationalList, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o operationalListDo) FindInBatches(result *[]*models.OperationalList, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o operationalListDo) Attrs(attrs ...field.AssignExpr) IOperationalListDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o operationalListDo) Assign(attrs ...field.AssignExpr) IOperationalListDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o operationalListDo) Joins(fields ...field.RelationField) IOperationalListDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o operationalListDo) Preload(fields ...field.RelationField) IOperationalListDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o operationalListDo) FirstOrInit() (*models.OperationalList, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.OperationalList), nil
	}
}

func (o operationalListDo) FirstOrCreate() (*models.OperationalList, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.OperationalList), nil
	}
}

func (o operationalListDo) FindByPage(offset int, limit int) (result []*models.OperationalList, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o operationalListDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o operationalListDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o operationalListDo) Delete(models ...*models.OperationalList) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *operationalListDo) withDO(do gen.Dao) *operationalListDo {
	o.DO = *do.(*gen.DO)
	return o
}
