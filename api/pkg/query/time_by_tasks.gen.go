// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/knovalab-systems/vytex/app/v1/models"
)

func newTimeByTask(db *gorm.DB, opts ...gen.DOOption) timeByTask {
	_timeByTask := timeByTask{}

	_timeByTask.timeByTaskDo.UseDB(db, opts...)
	_timeByTask.timeByTaskDo.UseModel(&models.TimeByTask{})

	tableName := _timeByTask.timeByTaskDo.TableName()
	_timeByTask.ALL = field.NewAsterisk(tableName)
	_timeByTask.ID = field.NewUint(tableName, "id")
	_timeByTask.Trazar = field.NewUint(tableName, "trazar")
	_timeByTask.Plantear = field.NewUint(tableName, "plantear")
	_timeByTask.Tender = field.NewUint(tableName, "tender")
	_timeByTask.Cortar = field.NewUint(tableName, "cortar")
	_timeByTask.Paquetear = field.NewUint(tableName, "paquetear")
	_timeByTask.Filetear = field.NewUint(tableName, "filetear")
	_timeByTask.Armar = field.NewUint(tableName, "armar")
	_timeByTask.Tapar = field.NewUint(tableName, "tapar")
	_timeByTask.Figurar = field.NewUint(tableName, "figurar")
	_timeByTask.Marquilla = field.NewUint(tableName, "marquilla")
	_timeByTask.Cerrar = field.NewUint(tableName, "cerrar")
	_timeByTask.Gafetes = field.NewUint(tableName, "gafetes")
	_timeByTask.Presillar = field.NewUint(tableName, "presillar")
	_timeByTask.Pulir = field.NewUint(tableName, "pulir")
	_timeByTask.Revisar = field.NewUint(tableName, "revisar")
	_timeByTask.Acabados = field.NewUint(tableName, "acabados")
	_timeByTask.Bolsas = field.NewUint(tableName, "bolsas")
	_timeByTask.Tiquetear = field.NewUint(tableName, "tiquetear")
	_timeByTask.Empacar = field.NewUint(tableName, "empacar")
	_timeByTask.Organizar = field.NewUint(tableName, "organizar")
	_timeByTask.Grabar = field.NewUint(tableName, "grabar")
	_timeByTask.Paletizar = field.NewUint(tableName, "paletizar")

	_timeByTask.fillFieldMap()

	return _timeByTask
}

type timeByTask struct {
	timeByTaskDo

	ALL       field.Asterisk
	ID        field.Uint
	Trazar    field.Uint
	Plantear  field.Uint
	Tender    field.Uint
	Cortar    field.Uint
	Paquetear field.Uint
	Filetear  field.Uint
	Armar     field.Uint
	Tapar     field.Uint
	Figurar   field.Uint
	Marquilla field.Uint
	Cerrar    field.Uint
	Gafetes   field.Uint
	Presillar field.Uint
	Pulir     field.Uint
	Revisar   field.Uint
	Acabados  field.Uint
	Bolsas    field.Uint
	Tiquetear field.Uint
	Empacar   field.Uint
	Organizar field.Uint
	Grabar    field.Uint
	Paletizar field.Uint

	fieldMap map[string]field.Expr
}

func (t timeByTask) Table(newTableName string) *timeByTask {
	t.timeByTaskDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t timeByTask) As(alias string) *timeByTask {
	t.timeByTaskDo.DO = *(t.timeByTaskDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *timeByTask) updateTableName(table string) *timeByTask {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewUint(table, "id")
	t.Trazar = field.NewUint(table, "trazar")
	t.Plantear = field.NewUint(table, "plantear")
	t.Tender = field.NewUint(table, "tender")
	t.Cortar = field.NewUint(table, "cortar")
	t.Paquetear = field.NewUint(table, "paquetear")
	t.Filetear = field.NewUint(table, "filetear")
	t.Armar = field.NewUint(table, "armar")
	t.Tapar = field.NewUint(table, "tapar")
	t.Figurar = field.NewUint(table, "figurar")
	t.Marquilla = field.NewUint(table, "marquilla")
	t.Cerrar = field.NewUint(table, "cerrar")
	t.Gafetes = field.NewUint(table, "gafetes")
	t.Presillar = field.NewUint(table, "presillar")
	t.Pulir = field.NewUint(table, "pulir")
	t.Revisar = field.NewUint(table, "revisar")
	t.Acabados = field.NewUint(table, "acabados")
	t.Bolsas = field.NewUint(table, "bolsas")
	t.Tiquetear = field.NewUint(table, "tiquetear")
	t.Empacar = field.NewUint(table, "empacar")
	t.Organizar = field.NewUint(table, "organizar")
	t.Grabar = field.NewUint(table, "grabar")
	t.Paletizar = field.NewUint(table, "paletizar")

	t.fillFieldMap()

	return t
}

func (t *timeByTask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *timeByTask) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 23)
	t.fieldMap["id"] = t.ID
	t.fieldMap["trazar"] = t.Trazar
	t.fieldMap["plantear"] = t.Plantear
	t.fieldMap["tender"] = t.Tender
	t.fieldMap["cortar"] = t.Cortar
	t.fieldMap["paquetear"] = t.Paquetear
	t.fieldMap["filetear"] = t.Filetear
	t.fieldMap["armar"] = t.Armar
	t.fieldMap["tapar"] = t.Tapar
	t.fieldMap["figurar"] = t.Figurar
	t.fieldMap["marquilla"] = t.Marquilla
	t.fieldMap["cerrar"] = t.Cerrar
	t.fieldMap["gafetes"] = t.Gafetes
	t.fieldMap["presillar"] = t.Presillar
	t.fieldMap["pulir"] = t.Pulir
	t.fieldMap["revisar"] = t.Revisar
	t.fieldMap["acabados"] = t.Acabados
	t.fieldMap["bolsas"] = t.Bolsas
	t.fieldMap["tiquetear"] = t.Tiquetear
	t.fieldMap["empacar"] = t.Empacar
	t.fieldMap["organizar"] = t.Organizar
	t.fieldMap["grabar"] = t.Grabar
	t.fieldMap["paletizar"] = t.Paletizar
}

func (t timeByTask) clone(db *gorm.DB) timeByTask {
	t.timeByTaskDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t timeByTask) replaceDB(db *gorm.DB) timeByTask {
	t.timeByTaskDo.ReplaceDB(db)
	return t
}

type timeByTaskDo struct{ gen.DO }

type ITimeByTaskDo interface {
	gen.SubQuery
	Debug() ITimeByTaskDo
	WithContext(ctx context.Context) ITimeByTaskDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITimeByTaskDo
	WriteDB() ITimeByTaskDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITimeByTaskDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITimeByTaskDo
	Not(conds ...gen.Condition) ITimeByTaskDo
	Or(conds ...gen.Condition) ITimeByTaskDo
	Select(conds ...field.Expr) ITimeByTaskDo
	Where(conds ...gen.Condition) ITimeByTaskDo
	Order(conds ...field.Expr) ITimeByTaskDo
	Distinct(cols ...field.Expr) ITimeByTaskDo
	Omit(cols ...field.Expr) ITimeByTaskDo
	Join(table schema.Tabler, on ...field.Expr) ITimeByTaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITimeByTaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITimeByTaskDo
	Group(cols ...field.Expr) ITimeByTaskDo
	Having(conds ...gen.Condition) ITimeByTaskDo
	Limit(limit int) ITimeByTaskDo
	Offset(offset int) ITimeByTaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITimeByTaskDo
	Unscoped() ITimeByTaskDo
	Create(values ...*models.TimeByTask) error
	CreateInBatches(values []*models.TimeByTask, batchSize int) error
	Save(values ...*models.TimeByTask) error
	First() (*models.TimeByTask, error)
	Take() (*models.TimeByTask, error)
	Last() (*models.TimeByTask, error)
	Find() ([]*models.TimeByTask, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.TimeByTask, err error)
	FindInBatches(result *[]*models.TimeByTask, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.TimeByTask) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITimeByTaskDo
	Assign(attrs ...field.AssignExpr) ITimeByTaskDo
	Joins(fields ...field.RelationField) ITimeByTaskDo
	Preload(fields ...field.RelationField) ITimeByTaskDo
	FirstOrInit() (*models.TimeByTask, error)
	FirstOrCreate() (*models.TimeByTask, error)
	FindByPage(offset int, limit int) (result []*models.TimeByTask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITimeByTaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t timeByTaskDo) Debug() ITimeByTaskDo {
	return t.withDO(t.DO.Debug())
}

func (t timeByTaskDo) WithContext(ctx context.Context) ITimeByTaskDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t timeByTaskDo) ReadDB() ITimeByTaskDo {
	return t.Clauses(dbresolver.Read)
}

func (t timeByTaskDo) WriteDB() ITimeByTaskDo {
	return t.Clauses(dbresolver.Write)
}

func (t timeByTaskDo) Session(config *gorm.Session) ITimeByTaskDo {
	return t.withDO(t.DO.Session(config))
}

func (t timeByTaskDo) Clauses(conds ...clause.Expression) ITimeByTaskDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t timeByTaskDo) Returning(value interface{}, columns ...string) ITimeByTaskDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t timeByTaskDo) Not(conds ...gen.Condition) ITimeByTaskDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t timeByTaskDo) Or(conds ...gen.Condition) ITimeByTaskDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t timeByTaskDo) Select(conds ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t timeByTaskDo) Where(conds ...gen.Condition) ITimeByTaskDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t timeByTaskDo) Order(conds ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t timeByTaskDo) Distinct(cols ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t timeByTaskDo) Omit(cols ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t timeByTaskDo) Join(table schema.Tabler, on ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t timeByTaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t timeByTaskDo) RightJoin(table schema.Tabler, on ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t timeByTaskDo) Group(cols ...field.Expr) ITimeByTaskDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t timeByTaskDo) Having(conds ...gen.Condition) ITimeByTaskDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t timeByTaskDo) Limit(limit int) ITimeByTaskDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t timeByTaskDo) Offset(offset int) ITimeByTaskDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t timeByTaskDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITimeByTaskDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t timeByTaskDo) Unscoped() ITimeByTaskDo {
	return t.withDO(t.DO.Unscoped())
}

func (t timeByTaskDo) Create(values ...*models.TimeByTask) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t timeByTaskDo) CreateInBatches(values []*models.TimeByTask, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t timeByTaskDo) Save(values ...*models.TimeByTask) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t timeByTaskDo) First() (*models.TimeByTask, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.TimeByTask), nil
	}
}

func (t timeByTaskDo) Take() (*models.TimeByTask, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.TimeByTask), nil
	}
}

func (t timeByTaskDo) Last() (*models.TimeByTask, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.TimeByTask), nil
	}
}

func (t timeByTaskDo) Find() ([]*models.TimeByTask, error) {
	result, err := t.DO.Find()
	return result.([]*models.TimeByTask), err
}

func (t timeByTaskDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.TimeByTask, err error) {
	buf := make([]*models.TimeByTask, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t timeByTaskDo) FindInBatches(result *[]*models.TimeByTask, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t timeByTaskDo) Attrs(attrs ...field.AssignExpr) ITimeByTaskDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t timeByTaskDo) Assign(attrs ...field.AssignExpr) ITimeByTaskDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t timeByTaskDo) Joins(fields ...field.RelationField) ITimeByTaskDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t timeByTaskDo) Preload(fields ...field.RelationField) ITimeByTaskDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t timeByTaskDo) FirstOrInit() (*models.TimeByTask, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.TimeByTask), nil
	}
}

func (t timeByTaskDo) FirstOrCreate() (*models.TimeByTask, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.TimeByTask), nil
	}
}

func (t timeByTaskDo) FindByPage(offset int, limit int) (result []*models.TimeByTask, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t timeByTaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t timeByTaskDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t timeByTaskDo) Delete(models ...*models.TimeByTask) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *timeByTaskDo) withDO(do gen.Dao) *timeByTaskDo {
	t.DO = *do.(*gen.DO)
	return t
}
