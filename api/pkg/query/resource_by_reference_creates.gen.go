// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/knovalab-systems/vytex/app/v1/models"
)

func newResourceByReferenceCreate(db *gorm.DB, opts ...gen.DOOption) resourceByReferenceCreate {
	_resourceByReferenceCreate := resourceByReferenceCreate{}

	_resourceByReferenceCreate.resourceByReferenceCreateDo.UseDB(db, opts...)
	_resourceByReferenceCreate.resourceByReferenceCreateDo.UseModel(&models.ResourceByReferenceCreate{})

	tableName := _resourceByReferenceCreate.resourceByReferenceCreateDo.TableName()
	_resourceByReferenceCreate.ALL = field.NewAsterisk(tableName)
	_resourceByReferenceCreate.Resource = field.NewUint(tableName, "resource")
	_resourceByReferenceCreate.XS2 = field.NewFloat64(tableName, "xs2")
	_resourceByReferenceCreate.XS = field.NewFloat64(tableName, "xs")
	_resourceByReferenceCreate.S = field.NewFloat64(tableName, "s")
	_resourceByReferenceCreate.M = field.NewFloat64(tableName, "m")
	_resourceByReferenceCreate.L = field.NewFloat64(tableName, "l")
	_resourceByReferenceCreate.XL = field.NewFloat64(tableName, "xl")
	_resourceByReferenceCreate.XL2 = field.NewFloat64(tableName, "xl2")
	_resourceByReferenceCreate.XL3 = field.NewFloat64(tableName, "xl3")
	_resourceByReferenceCreate.XL4 = field.NewFloat64(tableName, "xl4")
	_resourceByReferenceCreate.XL5 = field.NewFloat64(tableName, "xl5")
	_resourceByReferenceCreate.XL6 = field.NewFloat64(tableName, "xl6")
	_resourceByReferenceCreate.XL7 = field.NewFloat64(tableName, "xl7")
	_resourceByReferenceCreate.XL8 = field.NewFloat64(tableName, "xl8")

	_resourceByReferenceCreate.fillFieldMap()

	return _resourceByReferenceCreate
}

type resourceByReferenceCreate struct {
	resourceByReferenceCreateDo

	ALL      field.Asterisk
	Resource field.Uint
	XS2      field.Float64
	XS       field.Float64
	S        field.Float64
	M        field.Float64
	L        field.Float64
	XL       field.Float64
	XL2      field.Float64
	XL3      field.Float64
	XL4      field.Float64
	XL5      field.Float64
	XL6      field.Float64
	XL7      field.Float64
	XL8      field.Float64

	fieldMap map[string]field.Expr
}

func (r resourceByReferenceCreate) Table(newTableName string) *resourceByReferenceCreate {
	r.resourceByReferenceCreateDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r resourceByReferenceCreate) As(alias string) *resourceByReferenceCreate {
	r.resourceByReferenceCreateDo.DO = *(r.resourceByReferenceCreateDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *resourceByReferenceCreate) updateTableName(table string) *resourceByReferenceCreate {
	r.ALL = field.NewAsterisk(table)
	r.Resource = field.NewUint(table, "resource")
	r.XS2 = field.NewFloat64(table, "xs2")
	r.XS = field.NewFloat64(table, "xs")
	r.S = field.NewFloat64(table, "s")
	r.M = field.NewFloat64(table, "m")
	r.L = field.NewFloat64(table, "l")
	r.XL = field.NewFloat64(table, "xl")
	r.XL2 = field.NewFloat64(table, "xl2")
	r.XL3 = field.NewFloat64(table, "xl3")
	r.XL4 = field.NewFloat64(table, "xl4")
	r.XL5 = field.NewFloat64(table, "xl5")
	r.XL6 = field.NewFloat64(table, "xl6")
	r.XL7 = field.NewFloat64(table, "xl7")
	r.XL8 = field.NewFloat64(table, "xl8")

	r.fillFieldMap()

	return r
}

func (r *resourceByReferenceCreate) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *resourceByReferenceCreate) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 14)
	r.fieldMap["resource"] = r.Resource
	r.fieldMap["xs2"] = r.XS2
	r.fieldMap["xs"] = r.XS
	r.fieldMap["s"] = r.S
	r.fieldMap["m"] = r.M
	r.fieldMap["l"] = r.L
	r.fieldMap["xl"] = r.XL
	r.fieldMap["xl2"] = r.XL2
	r.fieldMap["xl3"] = r.XL3
	r.fieldMap["xl4"] = r.XL4
	r.fieldMap["xl5"] = r.XL5
	r.fieldMap["xl6"] = r.XL6
	r.fieldMap["xl7"] = r.XL7
	r.fieldMap["xl8"] = r.XL8
}

func (r resourceByReferenceCreate) clone(db *gorm.DB) resourceByReferenceCreate {
	r.resourceByReferenceCreateDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r resourceByReferenceCreate) replaceDB(db *gorm.DB) resourceByReferenceCreate {
	r.resourceByReferenceCreateDo.ReplaceDB(db)
	return r
}

type resourceByReferenceCreateDo struct{ gen.DO }

type IResourceByReferenceCreateDo interface {
	gen.SubQuery
	Debug() IResourceByReferenceCreateDo
	WithContext(ctx context.Context) IResourceByReferenceCreateDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IResourceByReferenceCreateDo
	WriteDB() IResourceByReferenceCreateDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IResourceByReferenceCreateDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IResourceByReferenceCreateDo
	Not(conds ...gen.Condition) IResourceByReferenceCreateDo
	Or(conds ...gen.Condition) IResourceByReferenceCreateDo
	Select(conds ...field.Expr) IResourceByReferenceCreateDo
	Where(conds ...gen.Condition) IResourceByReferenceCreateDo
	Order(conds ...field.Expr) IResourceByReferenceCreateDo
	Distinct(cols ...field.Expr) IResourceByReferenceCreateDo
	Omit(cols ...field.Expr) IResourceByReferenceCreateDo
	Join(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo
	RightJoin(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo
	Group(cols ...field.Expr) IResourceByReferenceCreateDo
	Having(conds ...gen.Condition) IResourceByReferenceCreateDo
	Limit(limit int) IResourceByReferenceCreateDo
	Offset(offset int) IResourceByReferenceCreateDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IResourceByReferenceCreateDo
	Unscoped() IResourceByReferenceCreateDo
	Create(values ...*models.ResourceByReferenceCreate) error
	CreateInBatches(values []*models.ResourceByReferenceCreate, batchSize int) error
	Save(values ...*models.ResourceByReferenceCreate) error
	First() (*models.ResourceByReferenceCreate, error)
	Take() (*models.ResourceByReferenceCreate, error)
	Last() (*models.ResourceByReferenceCreate, error)
	Find() ([]*models.ResourceByReferenceCreate, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ResourceByReferenceCreate, err error)
	FindInBatches(result *[]*models.ResourceByReferenceCreate, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.ResourceByReferenceCreate) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IResourceByReferenceCreateDo
	Assign(attrs ...field.AssignExpr) IResourceByReferenceCreateDo
	Joins(fields ...field.RelationField) IResourceByReferenceCreateDo
	Preload(fields ...field.RelationField) IResourceByReferenceCreateDo
	FirstOrInit() (*models.ResourceByReferenceCreate, error)
	FirstOrCreate() (*models.ResourceByReferenceCreate, error)
	FindByPage(offset int, limit int) (result []*models.ResourceByReferenceCreate, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IResourceByReferenceCreateDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r resourceByReferenceCreateDo) Debug() IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Debug())
}

func (r resourceByReferenceCreateDo) WithContext(ctx context.Context) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r resourceByReferenceCreateDo) ReadDB() IResourceByReferenceCreateDo {
	return r.Clauses(dbresolver.Read)
}

func (r resourceByReferenceCreateDo) WriteDB() IResourceByReferenceCreateDo {
	return r.Clauses(dbresolver.Write)
}

func (r resourceByReferenceCreateDo) Session(config *gorm.Session) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Session(config))
}

func (r resourceByReferenceCreateDo) Clauses(conds ...clause.Expression) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r resourceByReferenceCreateDo) Returning(value interface{}, columns ...string) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r resourceByReferenceCreateDo) Not(conds ...gen.Condition) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r resourceByReferenceCreateDo) Or(conds ...gen.Condition) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r resourceByReferenceCreateDo) Select(conds ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r resourceByReferenceCreateDo) Where(conds ...gen.Condition) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r resourceByReferenceCreateDo) Order(conds ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r resourceByReferenceCreateDo) Distinct(cols ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r resourceByReferenceCreateDo) Omit(cols ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r resourceByReferenceCreateDo) Join(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r resourceByReferenceCreateDo) LeftJoin(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r resourceByReferenceCreateDo) RightJoin(table schema.Tabler, on ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r resourceByReferenceCreateDo) Group(cols ...field.Expr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r resourceByReferenceCreateDo) Having(conds ...gen.Condition) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r resourceByReferenceCreateDo) Limit(limit int) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r resourceByReferenceCreateDo) Offset(offset int) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r resourceByReferenceCreateDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r resourceByReferenceCreateDo) Unscoped() IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Unscoped())
}

func (r resourceByReferenceCreateDo) Create(values ...*models.ResourceByReferenceCreate) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r resourceByReferenceCreateDo) CreateInBatches(values []*models.ResourceByReferenceCreate, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r resourceByReferenceCreateDo) Save(values ...*models.ResourceByReferenceCreate) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r resourceByReferenceCreateDo) First() (*models.ResourceByReferenceCreate, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.ResourceByReferenceCreate), nil
	}
}

func (r resourceByReferenceCreateDo) Take() (*models.ResourceByReferenceCreate, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.ResourceByReferenceCreate), nil
	}
}

func (r resourceByReferenceCreateDo) Last() (*models.ResourceByReferenceCreate, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.ResourceByReferenceCreate), nil
	}
}

func (r resourceByReferenceCreateDo) Find() ([]*models.ResourceByReferenceCreate, error) {
	result, err := r.DO.Find()
	return result.([]*models.ResourceByReferenceCreate), err
}

func (r resourceByReferenceCreateDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.ResourceByReferenceCreate, err error) {
	buf := make([]*models.ResourceByReferenceCreate, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r resourceByReferenceCreateDo) FindInBatches(result *[]*models.ResourceByReferenceCreate, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r resourceByReferenceCreateDo) Attrs(attrs ...field.AssignExpr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r resourceByReferenceCreateDo) Assign(attrs ...field.AssignExpr) IResourceByReferenceCreateDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r resourceByReferenceCreateDo) Joins(fields ...field.RelationField) IResourceByReferenceCreateDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r resourceByReferenceCreateDo) Preload(fields ...field.RelationField) IResourceByReferenceCreateDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r resourceByReferenceCreateDo) FirstOrInit() (*models.ResourceByReferenceCreate, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.ResourceByReferenceCreate), nil
	}
}

func (r resourceByReferenceCreateDo) FirstOrCreate() (*models.ResourceByReferenceCreate, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.ResourceByReferenceCreate), nil
	}
}

func (r resourceByReferenceCreateDo) FindByPage(offset int, limit int) (result []*models.ResourceByReferenceCreate, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r resourceByReferenceCreateDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r resourceByReferenceCreateDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r resourceByReferenceCreateDo) Delete(models ...*models.ResourceByReferenceCreate) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *resourceByReferenceCreateDo) withDO(do gen.Dao) *resourceByReferenceCreateDo {
	r.DO = *do.(*gen.DO)
	return r
}
